package ninemensmorris;
import java.io.*;
import java.util.*;
/**
 * 
 * @author Neerajaksha Gangaraju
 *
 */

//MiniMaxGame Program
public class MiniMaxGame {

	// Variable to keep track of the number of positions evaluated by static estimation function
	static int Static_positions_evaluated=0;

	static ArrayList<String> GenerateMovesMidgameEndgame(String board, char color)
	{
		// Returns the list produced by GenerateMove/GenerateHopping function when applied to board
		int count=0;
		char[] temp_board = board.toCharArray();
		for(int i=0;i<23;i++) {
			if(temp_board[i] == color) 
				count++;
		}
		if(count==3) 
			return (GenerateHopping(temp_board, color));
		else 
			return (GenerateMove(temp_board, color));
	}


	static ArrayList<String> GenerateHopping(char[] board, char player)
	{
		// Adds hopping generated board positions to list - "Positions_List"
		ArrayList<String> Positions_List = new ArrayList<String>();
		for(int i=0; i<23; i++)
		{
			if(board[i]==player)
			{
				for(int j=0; j<23; j++)
				{
					if(board[j]=='x')
					{
						// Create temporary copy of board 
						char[] tempcopy = new char[23];
						for(int k=0; k<23; k++)
						{
							tempcopy[k] = board[k];
						}
						tempcopy[i]='x';
						tempcopy[j]=player;

						// Check for milling
						if (closemill(j,tempcopy)) {
							if(player=='W'){
								// For WHITE Player with MILL, Remove a BLACK Position
								GenerateRemove(tempcopy, Positions_List, 'B');
							}
							else if(player=='B') {
								// For BLACK Player with MILL, Remove a WHITE Position
								GenerateRemove(tempcopy, Positions_List, 'W');
							}
						}
						else {
							// Add Board Position named - "New_position" in the List							
							String New_position = new String(tempcopy);
							Positions_List.add(New_position);
						}
					}
				}

			}

		}
		return Positions_List ;
	}


	static ArrayList<String> GenerateMove(char[] board,char player)
	{
		// Adds new generated board positions by moving to adjacent open spots in to list - "Positions_List"
		ArrayList<String> Positions_List = new ArrayList<String>();

		for(int i=0; i<23; i++)
		{
			if(board[i]==player)
			{
				int[] adjacent_pieces = neighbors(i);
				for(int j=0; j<adjacent_pieces.length; j++)
				{
					if(adjacent_pieces[j]!=999){
						if(board[adjacent_pieces[j]]=='x')
						{
							// Create temporary copy of board
							char[] tempcopy = new char[23];
							for(int k=0; k<23; k++)
							{
								tempcopy[k]=board[k];
							}
							tempcopy[i]='x';
							tempcopy[adjacent_pieces[j]]=player;

							// Check for milling
							if(closemill(adjacent_pieces[j], tempcopy)==true) {
								if(player=='W') {
									// For WHITE Player with MILL, Remove a BLACK Position		
									Positions_List = GenerateRemove(tempcopy, Positions_List, 'B');
								}
								else if(player=='B') {
									// For BLACK Player with MILL, Remove a WHITE Position
									Positions_List = GenerateRemove(tempcopy, Positions_List, 'W');
								}
							}
							else {
								// Add Board Position named - "New_position" in the List							
								String New_position = new String(tempcopy);
								Positions_List.add(New_position);}
						}
					}

				}

			}
		}
		return Positions_List;
	}

	static ArrayList<String> GenerateRemove(char[] board, ArrayList<String> Positions_List, char player)
	{
		// Removes the "player" pieces in the board and appends the new generated position to the list - "Positions_List"
		int List_Size = Positions_List.size();
		for(int i=0; i<23; i++)
		{
			if(board[i] == player)
			{
				if(!closemill(i,board))
				{
					char[] board_copy = new char[23];
					for(int j=0; j<23; j++)
					{
						board_copy[j] = board[j];
					}
					board_copy[i]='x';
					String New_position = new String(board_copy);
					Positions_List.add(New_position);
				}
			}
		}
		if(List_Size == Positions_List.size()) {
			// No "player" pieces were removed. Hence, no positions were added
			// Adding board position to the list
			String New_position = new String(board);
			Positions_List.add(New_position);

		}
		return Positions_List;	
	}

	static int[] neighbors(int j)
	{	int[] adjacent_list = new int[4];
	switch(j){
	case 0: adjacent_list[0]=1;adjacent_list[1]=3;adjacent_list[2]=8;adjacent_list[3]=999;break;
	case 1: adjacent_list[0]=0;adjacent_list[1]=4;adjacent_list[2]=2;adjacent_list[3]=999;break;
	case 2: adjacent_list[0]=1;adjacent_list[1]=5;adjacent_list[2]=13;adjacent_list[3]=999;break;
	case 3: adjacent_list[0]=0;adjacent_list[1]=9;adjacent_list[2]=4;adjacent_list[3]=6;break;
	case 4: adjacent_list[0]=1;adjacent_list[1]=3;adjacent_list[2]=5;adjacent_list[3]=999;break;
	case 5: adjacent_list[0]=4;adjacent_list[1]=7;adjacent_list[2]=12;adjacent_list[3]=2;break;
	case 6: adjacent_list[0]=3;adjacent_list[1]=7;adjacent_list[2]=10;adjacent_list[3]=999;break;
	case 7: adjacent_list[0]=6;adjacent_list[1]=11;adjacent_list[2]=5;adjacent_list[3]=999;break;
	case 8: adjacent_list[0]=0;adjacent_list[1]=9;adjacent_list[2]=20;adjacent_list[3]=999;break;
	case 9: adjacent_list[0]=3;adjacent_list[1]=8;adjacent_list[2]=17;adjacent_list[3]=10;break;
	case 10:adjacent_list[0]=6;adjacent_list[1]=14;adjacent_list[2]=9;adjacent_list[3]=999;break;
	case 11:adjacent_list[0]=7;adjacent_list[1]=16;adjacent_list[2]=12;adjacent_list[3]=999;break;
	case 12:adjacent_list[0]=5;adjacent_list[1]=11;adjacent_list[2]=19;adjacent_list[3]=13;break;
	case 13:adjacent_list[0]=2;adjacent_list[1]=12;adjacent_list[2]=22;adjacent_list[3]=999;break;
	case 14:adjacent_list[0]=10;adjacent_list[1]=15;adjacent_list[2]=17;adjacent_list[3]=999;break;
	case 15:adjacent_list[0]=18;adjacent_list[1]=14;adjacent_list[2]=16;adjacent_list[3]=999;break;
	case 16:adjacent_list[0]=11;adjacent_list[1]=15;adjacent_list[2]=19;adjacent_list[3]=999;break;
	case 17:adjacent_list[0]=9;adjacent_list[1]=20;adjacent_list[2]=18;adjacent_list[3]=14;break;
	case 18:adjacent_list[0]=15;adjacent_list[1]=17;adjacent_list[2]=21;adjacent_list[3]=19;break;
	case 19:adjacent_list[0]=12;adjacent_list[1]=16;adjacent_list[2]=18;adjacent_list[3]=22;break;
	case 20:adjacent_list[0]=8;adjacent_list[1]=17;adjacent_list[2]=21;adjacent_list[3]=999;break;
	case 21:adjacent_list[0]=20;adjacent_list[1]=18;adjacent_list[2]=22;adjacent_list[3]=999;break;
	case 22:adjacent_list[0]=13;adjacent_list[1]=19;adjacent_list[2]=21;adjacent_list[3]=999;break;
	}
		return adjacent_list;

	}

	static boolean closemill(int key,char[] board)
	{
		// Returns TRUE if mill forming possibility is found 
		char input_position = board[key];
		if(input_position=='B' || input_position=='W')
		{
			switch(key) {
			case 0:{if( (board[1]==input_position && board[2]==input_position) || (board[3]==input_position && board[6]==input_position) || (board[8]==input_position && board[20]==input_position) ) return true; else return false;}
			case 1:{if( (board[0]==input_position && board[2]==input_position) ) return true; else return false;}
			case 2:{if( (board[0]==input_position && board[1]==input_position) || (board[5]==input_position && board[7]==input_position) || (board[13]==input_position && board[22]==input_position) ){return true;} else return false;}
			case 3:{if( (board[0]==input_position && board[6]==input_position) || (board[17]==input_position && board[9]==input_position) || (board[4]==input_position && board[5]==input_position) ) return true; else return false;}
			case 4:{if( (board[3]==input_position && board[5]==input_position) ) return true; else return false;}
			case 5:{if( (board[3]==input_position && board[4]==input_position) || (board[12]==input_position && board[19]==input_position) || (board[2]==input_position && board[7]==input_position) ) return true; else return false;}
			case 6:{if( (board[0]==input_position && board[3]==input_position) || (board[10]==input_position && board[14]==input_position) ) return true; else return false;}
			case 7:{if( (board[11]==input_position && board[16]==input_position) || (board[5]==input_position && board[2]==input_position) ) return true; else return false;}
			case 8:{if( (board[0]==input_position && board[20]==input_position) || (board[9]==input_position && board[10]==input_position) ) return true; else return false;}
			case 9:{if( (board[8]==input_position && board[10]==input_position) || (board[17]==input_position && board[3]==input_position) ) return true; else return false;}
			case 10:{if( (board[14]==input_position && board[6]==input_position) || (board[8]==input_position && board[9]==input_position) ) return true; else return false;}
			case 11:{if( (board[7]==input_position && board[16]==input_position) || (board[12]==input_position && board[13]==input_position) ) return true; else return false;}
			case 12:{if( (board[11]==input_position && board[13]==input_position)|| (board[5]==input_position && board[19]==input_position) ) return true; else return false;}
			case 13:{if( (board[2]==input_position && board[22]==input_position) || (board[11]==input_position && board[12]==input_position) ) return true; else return false;}
			case 14:{if( (board[10]==input_position && board[6]==input_position) || (board[15]==input_position && board[16]==input_position) || (board[20]==input_position && board[17]==input_position) ) return true; else return false;}
			case 15:{if( (board[14]==input_position && board[16]==input_position) || (board[18]==input_position && board[21]==input_position) ) return true; else return false;}
			case 16:{if( (board[14]==input_position && board[15]==input_position) || (board[7]==input_position && board[11]==input_position) || (board[19]==input_position && board[22]==input_position) ) return true; else return false;}
			case 17:{if( (board[3]==input_position && board[9]==input_position) || (board[20]==input_position && board[14]==input_position) || (board[18]==input_position && board[19]==input_position) ) return true; else return false;}
			case 18:{if( (board[17]==input_position && board[19]==input_position) || (board[21]==input_position && board[15]==input_position) ) return true; else return false;}
			case 19:{if( (board[5]==input_position && board[12]==input_position) || (board[17]==input_position && board[18]==input_position) || (board[16]==input_position && board[22]==input_position) ) return true; else return false;}
			case 20:{if( (board[8]==input_position && board[0]==input_position) || (board[21]==input_position && board[22]==input_position) || (board[17]==input_position && board[14]==input_position) ) return true; else return false;}
			case 21:{if( (board[15]==input_position && board[18]==input_position) || (board[20]==input_position && board[22]==input_position) ) return true; else return false;}
			case 22:{if( (board[20]==input_position && board[21]==input_position) || (board[13]==input_position && board[2]==input_position) || (board[16]==input_position && board[19]==input_position) ) return true; else return false;}
			default: return false;
			}
		}
		else return false;

	}

	static genericMoveState MaxMin(genericMoveState board,int depth)
	{
		// MaxMin routine which returns the max_node
		String board_position = (String)board.getmoveState();

		if(depth==0) {
			// Call static_estimation for Leaf node which updates the node's minimax value
			return static_estimation(board, 'W');
		}
		else
		{	
			//Create Max-Node with input board position and set to small default minimax value of -100000
			genericMoveState max_node = new genericMoveState(board.getmoveState());
			max_node.setvalue(-100000);

			//Create parent node
			genericMoveState parent = new genericMoveState();

			//BoardList is the list that contains all possible moves generated by "GenerateMovesOpening" for 'W'
			ArrayList<String> BoardList = new ArrayList<String>();
			BoardList = GenerateMovesMidgameEndgame(board_position, 'W');

			for(int j=0; j<BoardList.size(); j++)
			{
				//Saving board position in "parent" object
				parent.setmoveState(BoardList.get(j));

				//Get Max-Node by comparing values in getMax routine
				max_node = getMax((Integer)max_node.getvalue(), (String)max_node.getmoveState(), (String)max_node.getinitialState(), (MinMax(parent,depth-1)));
			}

			//Update Max-Node's state
			max_node.setcurrentState(max_node.getinitialState());
			max_node.setinitialState(board_position);

			return max_node;
		}
	}

	static genericMoveState MinMax(genericMoveState board, int depth)
	{
		// MinMax routine which returns the min_node
		String board_position = (String)board.getmoveState();

		if(depth == 0) {
			// Call static_estimation for Leaf node which updates the node's minimax value
			return static_estimation(board, 'B');
		}
		else
		{	
			//Create Min-Node with input board position and set to large default minimax value of 100000
			genericMoveState min_node = new genericMoveState(board.getmoveState());
			min_node.setvalue(100000);

			//Create parent node
			genericMoveState parent = new genericMoveState();

			//BoardList is the list that contains all possible moves generated by "GenerateMovesOpening" for 'B'
			ArrayList<String> BoardList = new ArrayList<String>();
			BoardList = GenerateMovesMidgameEndgame(board_position, 'B');

			for(int i=0; i<BoardList.size(); i++)
			{
				//Saving board position in "parent" object
				parent.setmoveState(BoardList.get(i));

				//Get Min-Node by comparing values in getMin routine
				min_node = getMin((Integer)min_node.getvalue(), (String)min_node.getmoveState(), (String)min_node.getinitialState(), (MaxMin(parent,depth-1)) );

			}

			//Update Min-Node's state
			min_node.setcurrentState(min_node.getinitialState());
			min_node.setinitialState(board_position);

			return min_node;
		}
	}



	static genericMoveState getMax(Integer old_value, String move, String initial, genericMoveState new_object) {
		// Compares 'old_value' with value in 'new_object' and returns object with MAX value 
		if( old_value >= (Integer)new_object.getvalue() ) {
			// Construct a temporary object and fill the required fields
			genericMoveState temp_object = new genericMoveState();
			temp_object.setvalue(old_value);
			temp_object.setmoveState(move);
			temp_object.setinitialState(initial);
			return temp_object; 
		}
		else 
			return new_object; 
	} 

	static genericMoveState getMin(Integer old_value, String move, String initial, genericMoveState new_object) { 
		// Compares 'old_value' with value in 'new_object' and returns object with MIN value 
		if( old_value <= (Integer)new_object.getvalue()) {
			// Construct a temporary object and fill the required fields
			genericMoveState temp_object = new genericMoveState();
			temp_object.setvalue(old_value);
			temp_object.setmoveState(move);
			temp_object.setinitialState(initial);
			return temp_object; 
		}
		else 
			return new_object; 
	}

	static genericMoveState static_estimation(genericMoveState leaf, char player)
	{
		// Contains formula of static_estimation for Minimax_Opening state
		// Increment counter to find the number of positions evaluated by Static estimation function
		Static_positions_evaluated++;

		String board_position = (String)leaf.getmoveState();
		char[] board = board_position.toCharArray();
		int numBlackPieces=0, numWhitePieces=0;

		//Counts the number of WHITE and BLACK positions
		for(int i=0; i<23; i++)
		{
			if(board[i]=='W') {
				numWhitePieces++;
			}
			else if(board[i]=='B') {
				numBlackPieces++;
			}
		}

		ArrayList<String> BoardList = new ArrayList<String>();					
		BoardList = GenerateMovesMidgameEndgame(board_position, 'B');
		int numBlackMoves = BoardList.size();
		
		if (numBlackPieces <= 2) {
			leaf.setvalue(10000);
		}
		else if (numWhitePieces <= 2) {
			leaf.setvalue(-10000);
		}
		else if (numBlackMoves == 0) {
			leaf.setvalue(10000);
		}
		else {
			leaf.setvalue( (1000*(numWhitePieces - numBlackPieces)) - numBlackMoves);
		}

		return (leaf);
	}

	public static void main(String args[]) throws Exception
	{
		try
		{
			//Set DEPTH
			int depth=Integer.parseInt(args[2]);

			FileReader in = new FileReader(args[0]);
			BufferedReader br = new BufferedReader(in);

			//Read Input string
			String input = br.readLine();	
			FileWriter out = new FileWriter(args[1]);
			BufferedWriter write = new BufferedWriter(out);

			genericMoveState myboard = new genericMoveState(input);

			//output is the Max-node
			genericMoveState output = MaxMin(myboard,depth);

			//Get Minimax_extimate & bestmove
			int Minimax_extimate = (Integer)output.getvalue();
			String bestmove = (String)output.getcurrentState();

			System.out.println("Best Move    " + bestmove);

			//Print Minimax_extimate
			System.out.println("MinMax Estimate = " + Minimax_extimate);

			//Print Static_positions_evaluated
			System.out.println("Positions Evaluated:"+" stat "+Static_positions_evaluated);

			//Write output string along with minimax estimate and positions evaluated count
			out.write(bestmove + " " + Minimax_extimate + " " + Static_positions_evaluated);
			out.close();

		}catch(Exception e){
			e.printStackTrace();
		}


	}

}

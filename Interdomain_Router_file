//Interdomain_Router_file that guides each terminal to adhere to BGP protocol

#include <sysf/socket.h>
#include <sys/types.h>
#include <sys/time.h>
#include<netinet/in.h>
#include <netinet/in.h>
#include<fcntl.h>
#include <arpa/inet.h>
#include <netdb.h> 
#include<cstdlib>
#include <cstdio>
#include <iostream>
#include <fstream>
#include<sstream>
#include<string.h>
#include <cstring>
#include <fstream>
#include<sstream>

#define SIZE 1024
#define ID 1
#define MaxNeighborPlusOne 5
using namespace std;


int main(int argc, char *argv[]) {

	struct timeval ts; 
	ts.tv_sec=0;
	ts.tv_usec=0;
	time_t timerList[MaxNeighborPlusOne];
	ifstream inputFile;
	fd_set rset;	
	int sockfd[5]={9999}; 
	int n, slen, i=0, k, MaxNeighbors;
	char Buffer[SIZE];
	char KeepAlive[]="keepalivek";
	int m, lengthpath=0;
	struct sockaddr_in servaddr[5];
	struct hostent *h_server[5];
	double totalint, nonzeroint;
	int p=0,q=0,p1[10];
	int counter_alarm[MaxNeighborPlusOne]={0};
	double diff=10.0; 
	int start[MaxNeighborPlusOne]={0};
	int deletion[MaxNeighborPlusOne]={0};
	string a[100],r[100],por[100];
	string numfile;
	string router,port;
	slen=sizeof(servaddr[0]);

	inputFile.open("Config_file.txt");
	if (!inputFile.fail())
	{
		cout << "Input file is open.\n";
		while (inputFile >> numfile)
		{
			a[i]=numfile;
			i++;			
		}
		char *b=new char[a[ID-1].size()+1];
		b[a[ID-1].size()]=0;
		memcpy(b,a[ID-1].c_str(),a[ID-1].size());
		int j=0;
		while(b[j]!=')')
		{
			j++;
		}
		int l=j+1;
		while(l<=(a[ID-1].size()))
		{
			if (b[l]=='(')
			{
				p++;              
				for(int i = l+1; i<=l+5; i++)
				{
					router += b[i];
				}
				l=l+7;
				r[p]=router;
				router="";
				while(b[l]!=',')
				{
					port += b[l];
					l++;
				}
				por[p]=port;
				port="";
			}
			l++;
		}
		inputFile.close();
	}
	else
	{
		cout << "\nError, unable to open"<<endl;
	}
	//////////////////indices
	int count1=0;
	char index1[100];
	char *index = (char*)a[ID].c_str();
	for(int po=24;po<a[ID].size();po++)
	{
		if( index[po]=='i' || index[po]=='g')
		{
			count1++;
			if(index[po]=='i')
			{
				index1[count1]='i';
			}
			else
			{
				index1[count1]='g';
			}
		}
	}
	///////////////////////////Testing-File//////////////////////		
	for(i=1;i<=p;i++)
	{
		cout<<r[i]<<endl;
		stringstream(por[q+1]) >> p1[i];
		cout<<p1[i]<<endl;
		cout<<"index="<<index1[i]<<endl;
		q=q+1;                
	}
	//////////////////////File Operations Finished//////////////////////////////////
	MaxNeighbors=p+1;
	for(k=1; k<MaxNeighbors; k++)
	{
		const char *rt = r[k].c_str();
		if ((h_server[k] = gethostbyname(rt)) == NULL) 
		{ 
			cerr << "Error: Address acquire problem" << endl;
			exit(1);
		}
		if ( (sockfd[k] = socket(AF_INET,SOCK_DGRAM, 0)) < 0) 
		{
			cerr<<"Error: Socket Opening Issue"<<argv[0]<<endl;
			exit(1);
		}

		bzero(&servaddr[k], sizeof(servaddr[k])); /*Washing Address space*/
		servaddr[k].sin_family = AF_INET;
		servaddr[k].sin_addr.s_addr = htonl(INADDR_ANY); /*Local free IP addresses*/
		servaddr[k].sin_port = htons(p1[k]); /*Local free port numbers*/

		if (bind(sockfd[k], (struct sockaddr *)&servaddr[k], sizeof(servaddr[k])) < 0) 
		{
			cerr<<"Error: Bind Problem"<<argv[0]<<endl;
			exit(1);
		}

		servaddr[k].sin_addr = *((struct in_addr *) h_server[k]->h_addr);
	}

	string dest[100], path[100], str_dest, str, str_cmp="net01", str_own=",net01", str1, path1, tmpRNodeIndex, tmpNodeIndex, tmpRNodeIndex1, tmpNodeIndex1;
	int j=0, count=0, temp=1, loop=0, hop=1, length=0, recent=0, hop_count[50], tmp, tmp2=0, tmp3=0;
	char tmpBuffer[100][100],cmp[5],Buffer1[100];
	int alarm[MaxNeighbors];
	for(i=1;i<MaxNeighbors;i++)
	{
		alarm[i]=0;
	}
	for(i=1; i<MaxNeighbors; i++)
	{
		path[i-1]=r[i]; path[i-1]+=",net01"; 
		dest[i-1]=r[i];
		hop_count[i-1]=1;
	}
	count= MaxNeighbors-2;

	for(i=1; i<MaxNeighbors; i++)
	{
		for(int pi=0; pi<MaxNeighbors-1; pi++)
		{	const char *path2 = (path[pi]+"r").c_str();
		if (sendto(sockfd[i], path2, strlen(path2), 0, (struct sockaddr *) &servaddr[i], sizeof(servaddr[i])) < 0) 
		{
			cout<<"Error: Sendto Problem"<<argv[0]<<endl;
			exit(1);
		}
		}
	}
	for(i=1; i<MaxNeighbors; i++)
	{	char path2[]="net01r";
	if (sendto(sockfd[i], path2, strlen(path2), 0, (struct sockaddr *) &servaddr[i], sizeof(servaddr[i])) < 0) 
	{
		cout<<"Error: Sendto Problem"<<argv[0]<<endl;
		exit(1);
	}
	}

	for(;;)
	{

		FD_ZERO(&rset);
		FD_SET(0,&rset);

		for(i=1; i<MaxNeighbors; i++)
			FD_SET(sockfd[i],&rset);

		int max=sockfd[1];
		for(i=2; i<MaxNeighbors; i++)
		{
			if(max<sockfd[i])
				max=sockfd[i];
		}
		select(max+1,&rset,NULL,NULL,&ts);

		if(FD_ISSET(0,&rset))
		{
			memset(Buffer, 0, SIZE);
			cin>>Buffer;
			int s1=0;
			while(Buffer[s1])
			{s1++;}
			Buffer[s1]='d';


			s1++;
			tmpRNodeIndex="";
			tmpNodeIndex=""; 

			for(int tmp3=s1-6;tmp3<s1-1;tmp3++)
			{
				tmpNodeIndex+=Buffer[tmp3];
			}
			int ind=100;
			for(int yindex=0;yindex<=count;yindex++)
			{	
				if(tmpNodeIndex==dest[yindex])
				{
					ind=yindex;
					break;
				}
			}
			if(ind==100)
			{
				tmpNodeIndex="";
				tmpNodeIndex="net22";
				for(int yindex=0;yindex<=count;yindex++)
				{	
					if(tmpNodeIndex==dest[yindex])
					{
						ind=yindex;
						break;
					}
				}
			}
			const char *tmpPath = path[ind].c_str();
			int lengthpath1=strlen(tmpPath);

			for (int mi=lengthpath1-11; mi<lengthpath1-6;mi++)
			{
				tmpRNodeIndex+=tmpPath[mi];
			}


			int fi=0;
			for(i=1; i<MaxNeighbors; i++)
			{ 
			if(r[i]==tmpRNodeIndex)
			{  		fi=i;
			break;
			}
			}


			if (sendto(sockfd[fi], Buffer, sizeof(Buffer), 0, (struct sockaddr *) &servaddr[fi], sizeof(servaddr[fi])) < 0) 
			{
				cout<<"Error: Sendto Problem"<<argv[0]<<endl;
				exit(1);
			}
			memset(Buffer,0,SIZE);	


		}
		for(i=1; i<MaxNeighbors; i++)
		{
			if(FD_ISSET(sockfd[i],&rset))
			{
				memset(Buffer, 0, SIZE);
				if (recvfrom(sockfd[i], Buffer, SIZE, 0, (struct sockaddr *) &servaddr[i], (socklen_t*) &slen) < 0) 
				{
					cout<<"Error: Problem in recvfrom"<<argv[0]<<endl;
					exit(1);
				}
				time(&timerList[i]);
				start[i]=1;
				counter_alarm[i]=0;
				deletion[i]=1;
				cout<<"Message received "<<Buffer<<endl;
				int tmp7=0;
				while(Buffer[tmp7])
				{tmp7++;}
				str="";
				for(int i1 = 0; i1<tmp7-1; i1++)
				{  str += Buffer[i1];  }	

				int kl=strlen(Buffer);
				string tmpstr;

				for(int re=kl-6;re<kl-1;re++)
				{
					tmpstr+=Buffer[re];
				}
				for(int q=MaxNeighbors-1; q<=count && alarm[i]!=1; q++)
				{	
					const char *rx = path[q].c_str();
					lengthpath=strlen(rx);
					string tmpstr1;
					for (m=lengthpath-11; m<lengthpath-6;m++)
					{
						tmpstr1+=rx[m];
					}
					if(tmpstr1==tmpstr)
					{
						alarm[i]=1; 
					}
				}
				char tmpstr2[100];
				if(alarm[i]!=1)
				{	
					for(int m=0; m<=count; m++)
					{	
						const char *path4 = (path[m]+"r").c_str();

						if (sendto(sockfd[i], path4, strlen(path4), 0, (struct sockaddr *) &servaddr[i], sizeof(servaddr[i])) < 0) 
						{
							cout<<"Error: Sendto Problem"<<argv[0]<<endl;
							exit(1);
						}
					}
				}

				if(Buffer[tmp7-1]=='k')
				{
					strcat(Buffer, "a");
					if (sendto(sockfd[i], Buffer, sizeof(Buffer), 0, (struct sockaddr *) &servaddr[i], sizeof(servaddr[i])) < 0) 
					{
						cout<<"Error: Sendto Problem"<<argv[0]<<endl;
						exit(1);
					}	
				}
				else if(Buffer[tmp7-1]=='w')
				{
					int markw=0,len_of_pathw=0,lenw=0,indxw=0,trackerw[100]={NULL},opw,tmp4;

					string expired_nodew=str; 
					char dummyw[100];
					markw=0;  
					for(opw=0; opw<=count; opw++)
					{
						if (dest[opw]==expired_nodew) 
						{      //Found node which has expired timer
							cout<<"Found expired node above"<<endl;
							markw=1;
						}	
					}

					const char *dest_rmvw = expired_nodew.c_str();
					indxw=0;
					if(markw==1)
					{
						for(opw=0; opw<=count; opw++)
						{    
							len_of_pathw=(path[opw].size()); 
							const char *path_comparew = (path[opw]).c_str();
							lenw=0;
							while(lenw<=len_of_pathw)
							{       tmp4=0;		       	
							for(int varw=lenw; varw<=(lenw+4); varw++)
							{   
								dummyw[tmp4]=path_comparew[varw]; 
								tmp4++;

							}
							dummyw[tmp4]=NULL;
							if(strcmp(dummyw,dest_rmvw)==0)
							{ //expired node found in path

								//delete entry
								path[opw]="";
								dest[opw]="";
								trackerw[indxw]=opw; 
								indxw++;
								lenw=len_of_pathw+1;
							}
							else
							{
								lenw=lenw+6;
							} 
							}//while
						}//for
						indxw--;
						while(indxw>=0)
						{ 
							while(path[count]=="")
							{
								count=count-1;
							}
							while(trackerw[indxw]>count)
							{
								trackerw[indxw]=NULL;
								indxw--;                       
							}
							if(indxw>=0)
							{
								path[trackerw[indxw]]=path[count];
								dest[trackerw[indxw]]=dest[count];
								hop_count[trackerw[indxw]]=hop_count[count];
								path[count]="";			  
								dest[count]="";
								hop_count[count]=NULL;
								trackerw[indxw]=NULL;
								indxw--;
								count=count-1;
							}
						}
						for(k=1; k<MaxNeighbors; k++)
						{
							if(k!=i)
							{	
								if (sendto(sockfd[k], Buffer, sizeof(Buffer), 0, (struct sockaddr *) &servaddr[k], sizeof(servaddr[k])) < 0) 
								{
									cout<<"Error: Sendto Problem"<<argv[0]<<endl;
									exit(1);
								}
							}
						} 

						cout<<"BY NBR NEW TABLE"<<endl<<"count"<<count<<endl;
						for(int opw=0;opw<=count;opw++)
						{cout<<"Dest "<< dest[opw]<<" Path "<<path[opw]<<" Hops:"<<hop_count[opw]<<endl;}


					}//if

				}
				else if(Buffer[tmp7-1]=='r')
				{
					const char *Buffer1 = str.c_str();
					cout<<"Routing update ";
					for(int i1=0; i1<5; i1++)	
					{
						str_dest+=Buffer[i1];
					}


					for(int h=0;h<strlen(Buffer);h++)
					{
						if(Buffer[h]==',')
						{
							hop++;
						}
					}
					j=0;
					while( (path[j].compare(str)!= 0)&&(j<=count) )
					{
						j++;
					}

					if(j>count)
					{ 
						//Loop detection
						while(Buffer1[tmp3])
						{tmp2++;tmp3++;}
						length=0;
						while(length<tmp2)
						{
							tmp=0;
							for(int pk =0; pk<5; pk++)
							{  
								cmp[tmp]=Buffer1[length];
								tmp++;length++;
							}
							if((strcmp(cmp,"net01"))==0)
							{loop=1;} 
							length++;
						}


						if(loop!=1)
						{
							path1=str;
							path1+=",net01";
							int flag=0;							
							for(int cmp=0;cmp<=count; cmp++)
							{  

								if( (path1==path[cmp]) && (flag!=1))
								{
									flag=1;
								}
							}
							if(flag==0)
							{
								count++;
								dest[count]=str_dest;
								strcpy(tmpBuffer[count],Buffer1);
								strcat(tmpBuffer[count],",net01r");
								path[count]=str;
								path[count]+=str_own;
								hop_count[count]=hop;
								recent=1;
								for(k=1; k<MaxNeighbors; k++)
								{
									if(k!=i)
									{	
										if (sendto(sockfd[k], tmpBuffer[count], sizeof(tmpBuffer[count]), 0, (struct sockaddr *) &servaddr[k], sizeof(servaddr[k])) < 0) 
										{
											cout<<"Error: Sendto Problem"<<argv[0]<<endl;
											exit(1);
										}
									}
								}
							}
						}
						else
						{recent=0;}

					}
					cout<<"____TABLE_____"<<endl;
					for(int e=0;e<=count;e++)
					{cout<<"Dest "<<dest[e]<<" Path "<<path[e]<<" Hops:"<<hop_count[e]<<endl;}
					str="";
					str_dest="";
					hop=1;
					loop=0;
					cout<<endl;
					if(recent==1)
					{	
						cout <<endl << endl;
					}
				}
				/////////////////////////////////////////////////////////////////////////////////////
				if(Buffer[tmp7-1]=='d')
				{
					cout<<"DONE"<<endl;

					tmpRNodeIndex1="";
					tmpNodeIndex1=""; 

					for(int i=tmp7-6;i<tmp7-1;i++)
					{
						tmpNodeIndex1+=Buffer[i];
					}

					if((tmpNodeIndex1==str_cmp))
					{cout<<"MESSAGE RCVD DESTINATION:"<<Buffer<<endl;
					}
					else
					{

						int ind1=100;
						for(int yindex1=0;yindex1<=count;yindex1++)
						{	
							if(tmpNodeIndex1==dest[yindex1])
							{
								ind1=yindex1;
								break;
							}
						}
						if(ind1==100)
						{
							tmpNodeIndex1="";
							tmpNodeIndex1="net22";
							for(int yindex=0;yindex<=count;yindex++)
							{	
								if(tmpNodeIndex1==dest[yindex])
								{
									ind1=yindex;
									break;
								}
							}
						}
						const char *tmpPath1 = path[ind1].c_str();
						int lengthpath2=strlen(tmpPath1);

						for (int mi1=lengthpath2-11; mi1<lengthpath2-6;mi1++)
						{
							tmpRNodeIndex1+=tmpPath1[mi1];
						}


						int tmp1=0;
						for(i=1; i<MaxNeighbors; i++)
						{ 
							if(r[i]==tmpRNodeIndex1)
							{  	tmp1=i;
								break;
							}
						}


						if (sendto(sockfd[tmp1], Buffer, sizeof(Buffer), 0, (struct sockaddr *) &servaddr[tmp1], sizeof(servaddr[tmp1])) < 0) 
						{
							cout<<"Error: Sendto Problem"<<argv[0]<<endl;
							exit(1);
						}	


					}


					memset(Buffer,0,SIZE);
				}

				/////////////////////////////////////////////////////////////////////////////////
			}
		}
		for(i=1; i<MaxNeighbors; i++)
		{
			time(&timerList[0]);
			double x=difftime(timerList[0],timerList[i]);
			if(x>diff && start[i]==1)
			{
				if(counter_alarm[i]<3)
				{
					counter_alarm[i] +=1;
					time(&timerList[i]);
					if (sendto(sockfd[i], KeepAlive, sizeof(KeepAlive), 0, (struct sockaddr *) &servaddr[i], sizeof(servaddr[i])) < 0) 
					{
						cout<<"Error: Sendto Problem"<<argv[0]<<endl;
						exit(1);
					}
				}
				else
				{
					start[i]=0;
					//withdraw msg
					int mark=0,len_of_path=0,len=0,indx=0,tracker[100]={NULL},op,tmp5;

					string expired_node=r[i];
					char dummy[100];

					for(op=0; op<=count; op++)
					{
						if (dest[op]==expired_node) 
						{      //Found node which has expired timer
							cout<<"Found expired node below"<<endl;
							mark=1;
						}	
					}
					const char *dest_rmv=expired_node.c_str();


					indx=0;
					if(mark==1)
					{
						for(op=0; op<=count; op++)
						{    
							len_of_path=(path[op].size()); 
							const char *path_compare = (path[op]).c_str();
							len=0;
							while(len<=len_of_path)
							{   	tmp5=0;		       	
							for(int var=len; var<=(len+4); var++)
							{   
								dummy[tmp5]=path_compare[var]; 
								tmp5++;

							}
							dummy[tmp5]=NULL;
							if(strcmp(dummy,dest_rmv)==0)
							{ //expired node found in path

								//delete entry
								path[op]="";
								dest[op]="";
								tracker[indx]=op; 
								cout<<"indx"<<indx<<endl<<tracker[indx]<<endl;

								indx++;
								len=len_of_path+1;
							}
							else
							{
								len=len+6;
							} 
							}//while
						}//for
						cout<<"cnt_befor"<<count<<endl;
						indx--;
						while(indx>=0)
						{ 
							while(path[count]=="")
							{
								count=count-1;
								if(count<0)
								{break;}
							}
							if(count<0)
							{break;}

							while(tracker[indx]>count)
							{
								tracker[indx]=NULL;
								indx--;                       
							} cout<<"indx_ff"<<indx<<endl<<"cn"<<count<<endl;
							if(indx>=0)
							{
								path[tracker[indx]]=path[count];
								dest[tracker[indx]]=dest[count];
								hop_count[tracker[indx]]=hop_count[count];
								path[count]="";			  
								dest[count]="";
								hop_count[count]=NULL;
								tracker[indx]=NULL;
								indx--;
								count=count-1; cout<<"del_count"<<count<<endl;
							}cout<<"true"<<endl;
						}
						expired_node+="w";
						const char *dest_rmvq=expired_node.c_str();
						for(k=1; k<MaxNeighbors; k++)
						{
							if(k!=i)
							{	
								if (sendto(sockfd[k], dest_rmvq, sizeof(dest_rmvq), 0, (struct sockaddr *) &servaddr[k], sizeof(servaddr[k])) < 0) 
								{
									cout<<"Error: Sendto Problem"<<argv[0]<<endl;
									exit(1);
								}
							}
						} 

					}//if

					cout<<"NEW TABLE"<<endl<<"count"<<count<<endl;
					for(int op=0;op<=count;op++)
					{cout<<"Dest "<< dest[op]<<" Path "<<path[op]<<" Hops:"<<hop_count[op]<<endl;}

					alarm[i]=0;
				}
			}
		}
	}

	return 0;
}
